// -------------------------------------------------------------
// 
// File Name: hdlsrc\LLE\Image_Filter1.v
// Created: 2020-07-09 10:41:45
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Image_Filter1
// Source Path: LLE/LLEHDL/IterativeFilter/Image Filter1
// Hierarchy Level: 2
// 
// Image Filter
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Image_Filter1
          (clk,
           reset,
           enb,
           in0,
           in1_hStart,
           in1_hEnd,
           in1_vStart,
           in1_vEnd,
           in1_valid,
           out0,
           out1_hStart,
           out1_hEnd,
           out1_vStart,
           out1_vEnd,
           out1_valid);


  input   clk;
  input   reset;
  input   enb;
  input   [11:0] in0;  // ufix12_En4
  input   in1_hStart;
  input   in1_hEnd;
  input   in1_vStart;
  input   in1_vEnd;
  input   in1_valid;
  output  [15:0] out0;  // ufix16_En8
  output  out1_hStart;
  output  out1_hEnd;
  output  out1_vStart;
  output  out1_vEnd;
  output  out1_valid;


  reg [11:0] dataInReg;  // ufix12_En4
  reg  hStartInReg;
  reg  hendInReg;
  reg  vStartInReg;
  reg  vendInReg;
  reg  validInReg;
  wire [11:0] LMKDataOut_0;  // ufix12_En4
  wire [11:0] LMKDataOut_1;  // ufix12_En4
  wire [11:0] LMKDataOut_2;  // ufix12_En4
  wire LMKhStartOut;
  wire LMKhEndOut;
  wire LMKvStartOut;
  wire LMKvEndOut;
  wire LMKvalidOut;
  wire LMKprocessOut;
  wire [15:0] preFilterDataOut;  // ufix16_En8
  wire prehStartOut;
  wire prehEndOut;
  wire prevStartOut;
  wire prevEndOut;
  wire preValidOut;
  wire [15:0] zeroOut_1;  // ufix16_En8
  wire [15:0] preDataOut;  // ufix16_En8
  reg [15:0] intdelay_reg [0:3];  // ufix16 [4]
  wire [15:0] intdelay_reg_next [0:3];  // ufix16_En8 [4]
  wire [15:0] dataOut;  // ufix16_En8
  reg  [0:3] intdelay_reg_1;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_1;  // ufix1 [4]
  wire hStartOut;
  reg  [0:3] intdelay_reg_2;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_2;  // ufix1 [4]
  wire hEndOut;
  reg  [0:3] intdelay_reg_3;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_3;  // ufix1 [4]
  wire vStartOut;
  reg  [0:3] intdelay_reg_4;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_4;  // ufix1 [4]
  wire vEndOut;
  reg  [0:3] intdelay_reg_5;  // ufix1 [4]
  wire [0:3] intdelay_reg_next_5;  // ufix1 [4]
  wire validOut;


  always @(posedge clk or posedge reset)
    begin : reg_rsvd_process
      if (reset == 1'b1) begin
        dataInReg <= 12'b000000000000;
      end
      else begin
        if (enb) begin
          dataInReg <= in0;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_1_process
      if (reset == 1'b1) begin
        hStartInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          hStartInReg <= in1_hStart;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_2_process
      if (reset == 1'b1) begin
        hendInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          hendInReg <= in1_hEnd;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_3_process
      if (reset == 1'b1) begin
        vStartInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          vStartInReg <= in1_vStart;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_4_process
      if (reset == 1'b1) begin
        vendInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          vendInReg <= in1_vEnd;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : reg_rsvd_5_process
      if (reset == 1'b1) begin
        validInReg <= 1'b0;
      end
      else begin
        if (enb) begin
          validInReg <= in1_valid;
        end
      end
    end



  LineBuffer_block2 u_LineBuffer (.clk(clk),
                                  .reset(reset),
                                  .enb(enb),
                                  .dataIn(dataInReg),  // ufix12_En4
                                  .hStartIn(hStartInReg),
                                  .hEndIn(hendInReg),
                                  .vStartIn(vStartInReg),
                                  .vEndIn(vendInReg),
                                  .validIn(validInReg),
                                  .dataOut_0(LMKDataOut_0),  // ufix12_En4
                                  .dataOut_1(LMKDataOut_1),  // ufix12_En4
                                  .dataOut_2(LMKDataOut_2),  // ufix12_En4
                                  .hStartOut(LMKhStartOut),
                                  .hEndOut(LMKhEndOut),
                                  .vStartOut(LMKvStartOut),
                                  .vEndOut(LMKvEndOut),
                                  .validOut(LMKvalidOut),
                                  .processDataOut(LMKprocessOut)
                                  );

  FIR2DKernel_block2 u_imagekernel_inst (.clk(clk),
                                         .reset(reset),
                                         .enb(enb),
                                         .dataIn_0(LMKDataOut_0),  // ufix12_En4
                                         .dataIn_1(LMKDataOut_1),  // ufix12_En4
                                         .dataIn_2(LMKDataOut_2),  // ufix12_En4
                                         .vStartIn(LMKhStartOut),
                                         .vEndIn(LMKhEndOut),
                                         .hStartIn(LMKvStartOut),
                                         .hEndIn(LMKvEndOut),
                                         .validIn(LMKvalidOut),
                                         .processData(LMKprocessOut),
                                         .dataOut(preFilterDataOut),  // ufix16_En8
                                         .vStartOut(prehStartOut),
                                         .vEndOut(prehEndOut),
                                         .hStartOut(prevStartOut),
                                         .hEndOut(prevEndOut),
                                         .validOut(preValidOut)
                                         );

  assign zeroOut_1 = 16'b0000000000000000;



  assign preDataOut = (preValidOut == 1'b0 ? zeroOut_1 :
              preFilterDataOut);



  always @(posedge clk or posedge reset)
    begin : intdelay_process
      if (reset == 1'b1) begin
        intdelay_reg[0] <= 16'b0000000000000000;
        intdelay_reg[1] <= 16'b0000000000000000;
        intdelay_reg[2] <= 16'b0000000000000000;
        intdelay_reg[3] <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          intdelay_reg[0] <= intdelay_reg_next[0];
          intdelay_reg[1] <= intdelay_reg_next[1];
          intdelay_reg[2] <= intdelay_reg_next[2];
          intdelay_reg[3] <= intdelay_reg_next[3];
        end
      end
    end

  assign dataOut = intdelay_reg[3];
  assign intdelay_reg_next[0] = preDataOut;
  assign intdelay_reg_next[1] = intdelay_reg[0];
  assign intdelay_reg_next[2] = intdelay_reg[1];
  assign intdelay_reg_next[3] = intdelay_reg[2];



  assign out0 = dataOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_1_process
      if (reset == 1'b1) begin
        intdelay_reg_1[0] <= 1'b0;
        intdelay_reg_1[1] <= 1'b0;
        intdelay_reg_1[2] <= 1'b0;
        intdelay_reg_1[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_1[0] <= intdelay_reg_next_1[0];
          intdelay_reg_1[1] <= intdelay_reg_next_1[1];
          intdelay_reg_1[2] <= intdelay_reg_next_1[2];
          intdelay_reg_1[3] <= intdelay_reg_next_1[3];
        end
      end
    end

  assign hStartOut = intdelay_reg_1[3];
  assign intdelay_reg_next_1[0] = prehStartOut;
  assign intdelay_reg_next_1[1] = intdelay_reg_1[0];
  assign intdelay_reg_next_1[2] = intdelay_reg_1[1];
  assign intdelay_reg_next_1[3] = intdelay_reg_1[2];



  assign out1_hStart = hStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_2_process
      if (reset == 1'b1) begin
        intdelay_reg_2[0] <= 1'b0;
        intdelay_reg_2[1] <= 1'b0;
        intdelay_reg_2[2] <= 1'b0;
        intdelay_reg_2[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_2[0] <= intdelay_reg_next_2[0];
          intdelay_reg_2[1] <= intdelay_reg_next_2[1];
          intdelay_reg_2[2] <= intdelay_reg_next_2[2];
          intdelay_reg_2[3] <= intdelay_reg_next_2[3];
        end
      end
    end

  assign hEndOut = intdelay_reg_2[3];
  assign intdelay_reg_next_2[0] = prehEndOut;
  assign intdelay_reg_next_2[1] = intdelay_reg_2[0];
  assign intdelay_reg_next_2[2] = intdelay_reg_2[1];
  assign intdelay_reg_next_2[3] = intdelay_reg_2[2];



  assign out1_hEnd = hEndOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_3_process
      if (reset == 1'b1) begin
        intdelay_reg_3[0] <= 1'b0;
        intdelay_reg_3[1] <= 1'b0;
        intdelay_reg_3[2] <= 1'b0;
        intdelay_reg_3[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_3[0] <= intdelay_reg_next_3[0];
          intdelay_reg_3[1] <= intdelay_reg_next_3[1];
          intdelay_reg_3[2] <= intdelay_reg_next_3[2];
          intdelay_reg_3[3] <= intdelay_reg_next_3[3];
        end
      end
    end

  assign vStartOut = intdelay_reg_3[3];
  assign intdelay_reg_next_3[0] = prevStartOut;
  assign intdelay_reg_next_3[1] = intdelay_reg_3[0];
  assign intdelay_reg_next_3[2] = intdelay_reg_3[1];
  assign intdelay_reg_next_3[3] = intdelay_reg_3[2];



  assign out1_vStart = vStartOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_4_process
      if (reset == 1'b1) begin
        intdelay_reg_4[0] <= 1'b0;
        intdelay_reg_4[1] <= 1'b0;
        intdelay_reg_4[2] <= 1'b0;
        intdelay_reg_4[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_4[0] <= intdelay_reg_next_4[0];
          intdelay_reg_4[1] <= intdelay_reg_next_4[1];
          intdelay_reg_4[2] <= intdelay_reg_next_4[2];
          intdelay_reg_4[3] <= intdelay_reg_next_4[3];
        end
      end
    end

  assign vEndOut = intdelay_reg_4[3];
  assign intdelay_reg_next_4[0] = prevEndOut;
  assign intdelay_reg_next_4[1] = intdelay_reg_4[0];
  assign intdelay_reg_next_4[2] = intdelay_reg_4[1];
  assign intdelay_reg_next_4[3] = intdelay_reg_4[2];



  assign out1_vEnd = vEndOut;

  always @(posedge clk or posedge reset)
    begin : intdelay_5_process
      if (reset == 1'b1) begin
        intdelay_reg_5[0] <= 1'b0;
        intdelay_reg_5[1] <= 1'b0;
        intdelay_reg_5[2] <= 1'b0;
        intdelay_reg_5[3] <= 1'b0;
      end
      else begin
        if (enb) begin
          intdelay_reg_5[0] <= intdelay_reg_next_5[0];
          intdelay_reg_5[1] <= intdelay_reg_next_5[1];
          intdelay_reg_5[2] <= intdelay_reg_next_5[2];
          intdelay_reg_5[3] <= intdelay_reg_next_5[3];
        end
      end
    end

  assign validOut = intdelay_reg_5[3];
  assign intdelay_reg_next_5[0] = preValidOut;
  assign intdelay_reg_next_5[1] = intdelay_reg_5[0];
  assign intdelay_reg_next_5[2] = intdelay_reg_5[1];
  assign intdelay_reg_next_5[3] = intdelay_reg_5[2];



  assign out1_valid = validOut;

endmodule  // Image_Filter1

