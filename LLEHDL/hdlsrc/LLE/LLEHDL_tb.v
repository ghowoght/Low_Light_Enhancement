// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\LLE\LLEHDL_tb.v
// Created: 2020-07-09 11:03:06
// 
// Generated by MATLAB 9.8 and HDL Coder 3.16
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// pixelOut_0                    ce_out        1
// pixelOut_1                    ce_out        1
// pixelOut_2                    ce_out        1
// ctrlOut_hStart                ce_out        1
// ctrlOut_hEnd                  ce_out        1
// ctrlOut_vStart                ce_out        1
// ctrlOut_vEnd                  ce_out        1
// ctrlOut_valid                 ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: LLEHDL_tb
// Source Path: 
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module LLEHDL_tb;



  reg  clk;
  reg  reset;
  wire clk_enable;
  wire ctrlOut_valid_done;  // ufix1
  wire rdEnb;
  wire ctrlOut_valid_done_enb;  // ufix1
  reg [18:0] pixelOut_0_addr;  // ufix19
  wire ctrlOut_valid_lastAddr;  // ufix1
  wire resetn;
  reg  check6_done;  // ufix1
  wire ctrlOut_vEnd_done;  // ufix1
  wire ctrlOut_vEnd_done_enb;  // ufix1
  wire ctrlOut_vEnd_lastAddr;  // ufix1
  reg  check5_done;  // ufix1
  wire ctrlOut_vStart_done;  // ufix1
  wire ctrlOut_vStart_done_enb;  // ufix1
  wire ctrlOut_vStart_lastAddr;  // ufix1
  reg  check4_done;  // ufix1
  wire ctrlOut_hEnd_done;  // ufix1
  wire ctrlOut_hEnd_done_enb;  // ufix1
  wire ctrlOut_hEnd_lastAddr;  // ufix1
  reg  check3_done;  // ufix1
  wire ctrlOut_hStart_done;  // ufix1
  wire ctrlOut_hStart_done_enb;  // ufix1
  wire ctrlOut_hStart_lastAddr;  // ufix1
  reg  check2_done;  // ufix1
  wire pixelOut_0_done;  // ufix1
  wire pixelOut_0_done_enb;  // ufix1
  wire pixelOut_0_active;  // ufix1
  reg [18:0] Frame_To_Pixels_out1_addr;  // ufix19
  wire [18:0] Frame_To_Pixels_out2_4_bus_addr_delay_1;  // ufix19
  reg  tb_enb_delay;
  reg signed [31:0] fp_ctrlIn_valid;  // sfix32
  reg  rawData_ctrlIn_valid;
  reg signed [31:0] status_ctrlIn_valid;  // sfix32
  reg  holdData_ctrlIn_valid;
  reg  ctrlIn_valid_offset;
  wire ctrlIn_valid;
  wire [18:0] Frame_To_Pixels_out2_3_bus_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlIn_vEnd;  // sfix32
  reg  rawData_ctrlIn_vEnd;
  reg signed [31:0] status_ctrlIn_vEnd;  // sfix32
  reg  holdData_ctrlIn_vEnd;
  reg  ctrlIn_vEnd_offset;
  wire ctrlIn_vEnd;
  wire [18:0] Frame_To_Pixels_out2_2_bus_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlIn_vStart;  // sfix32
  reg  rawData_ctrlIn_vStart;
  reg signed [31:0] status_ctrlIn_vStart;  // sfix32
  reg  holdData_ctrlIn_vStart;
  reg  ctrlIn_vStart_offset;
  wire ctrlIn_vStart;
  wire [18:0] Frame_To_Pixels_out2_1_bus_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlIn_hEnd;  // sfix32
  reg  rawData_ctrlIn_hEnd;
  reg signed [31:0] status_ctrlIn_hEnd;  // sfix32
  reg  holdData_ctrlIn_hEnd;
  reg  ctrlIn_hEnd_offset;
  wire ctrlIn_hEnd;
  wire [18:0] Frame_To_Pixels_out2_bus_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlIn_hStart;  // sfix32
  reg  rawData_ctrlIn_hStart;
  reg signed [31:0] status_ctrlIn_hStart;  // sfix32
  reg  holdData_ctrlIn_hStart;
  reg  ctrlIn_hStart_offset;
  wire ctrlIn_hStart;
  wire [18:0] Frame_To_Pixels_out1_addr_delay;  // ufix19
  reg signed [31:0] fp_pixelIn_2;  // sfix32
  reg [7:0] rawData_pixelIn_2;  // uint8
  reg signed [31:0] status_pixelIn_2;  // sfix32
  reg [7:0] holdData_pixelIn_2;  // uint8
  reg [7:0] pixelIn_2_offset;  // uint8
  wire [7:0] pixelIn_2;  // uint8
  reg signed [31:0] fp_pixelIn_1;  // sfix32
  reg [7:0] rawData_pixelIn_1;  // uint8
  reg signed [31:0] status_pixelIn_1;  // sfix32
  reg [7:0] holdData_pixelIn_1;  // uint8
  reg [7:0] pixelIn_1_offset;  // uint8
  wire [7:0] pixelIn_1;  // uint8
  wire Frame_To_Pixels_out1_active;  // ufix1
  wire Frame_To_Pixels_out1_enb;  // ufix1
  reg signed [31:0] fp_pixelIn_0;  // sfix32
  reg [7:0] rawData_pixelIn_0;  // uint8
  reg signed [31:0] status_pixelIn_0;  // sfix32
  reg [7:0] holdData_pixelIn_0;  // uint8
  reg [7:0] pixelIn_0_offset;  // uint8
  wire [7:0] pixelIn_0;  // uint8
  wire snkDone;
  wire snkDonen;
  wire tb_enb;
  wire ce_out;
  wire [7:0] pixelOut_0;  // uint8
  wire [7:0] pixelOut_1;  // uint8
  wire [7:0] pixelOut_2;  // uint8
  wire ctrlOut_hStart;
  wire ctrlOut_hEnd;
  wire ctrlOut_vStart;
  wire ctrlOut_vEnd;
  wire ctrlOut_valid;
  wire pixelOut_0_enb;  // ufix1
  wire pixelOut_0_lastAddr;  // ufix1
  reg  check1_done;  // ufix1
  wire [18:0] pixelOut_0_addr_delay_1;  // ufix19
  reg signed [31:0] fp_pixelOut_0_0_expected;  // sfix32
  reg [7:0] pixelOut_0_0_expected;  // uint8
  reg signed [31:0] status_pixelOut_0_0_expected;  // sfix32
  wire [7:0] pixelOut_0_ref;  // uint8
  reg  pixelOut_0_testFailure;  // ufix1
  reg signed [31:0] fp_pixelOut_0_1_expected;  // sfix32
  reg [7:0] pixelOut_0_1_expected;  // uint8
  reg signed [31:0] status_pixelOut_0_1_expected;  // sfix32
  wire [7:0] pixelOut_1_ref;  // uint8
  reg  pixelOut_1_testFailure;  // ufix1
  reg signed [31:0] fp_pixelOut_0_2_expected;  // sfix32
  reg [7:0] pixelOut_0_2_expected;  // uint8
  reg signed [31:0] status_pixelOut_0_2_expected;  // sfix32
  wire [7:0] pixelOut_2_ref;  // uint8
  reg  pixelOut_2_testFailure;  // ufix1
  wire [18:0] ctrlOut_hStart_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlOut_hStart_expected;  // sfix32
  reg  ctrlOut_hStart_expected;
  reg signed [31:0] status_ctrlOut_hStart_expected;  // sfix32
  wire ctrlOut_hStart_ref;
  reg  ctrlOut_hStart_testFailure;  // ufix1
  wire [18:0] ctrlOut_hEnd_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlOut_hEnd_expected;  // sfix32
  reg  ctrlOut_hEnd_expected;
  reg signed [31:0] status_ctrlOut_hEnd_expected;  // sfix32
  wire ctrlOut_hEnd_ref;
  reg  ctrlOut_hEnd_testFailure;  // ufix1
  wire [18:0] ctrlOut_vStart_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlOut_vStart_expected;  // sfix32
  reg  ctrlOut_vStart_expected;
  reg signed [31:0] status_ctrlOut_vStart_expected;  // sfix32
  wire ctrlOut_vStart_ref;
  reg  ctrlOut_vStart_testFailure;  // ufix1
  wire [18:0] ctrlOut_vEnd_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlOut_vEnd_expected;  // sfix32
  reg  ctrlOut_vEnd_expected;
  reg signed [31:0] status_ctrlOut_vEnd_expected;  // sfix32
  wire ctrlOut_vEnd_ref;
  reg  ctrlOut_vEnd_testFailure;  // ufix1
  wire [18:0] ctrlOut_valid_addr_delay_1;  // ufix19
  reg signed [31:0] fp_ctrlOut_valid_expected;  // sfix32
  reg  ctrlOut_valid_expected;
  reg signed [31:0] status_ctrlOut_valid_expected;  // sfix32
  wire ctrlOut_valid_ref;
  reg  ctrlOut_valid_testFailure;  // ufix1
  wire testFailure;  // ufix1


  assign ctrlOut_valid_done_enb = ctrlOut_valid_done & rdEnb;



  assign ctrlOut_valid_lastAddr = pixelOut_0_addr >= 19'b1101100101001110000;



  assign ctrlOut_valid_done = ctrlOut_valid_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_6
      if (reset) begin
        check6_done <= 0;
      end
      else begin
        if (ctrlOut_valid_done_enb) begin
          check6_done <= ctrlOut_valid_done;
        end
      end
    end

  assign ctrlOut_vEnd_done_enb = ctrlOut_vEnd_done & rdEnb;



  assign ctrlOut_vEnd_lastAddr = pixelOut_0_addr >= 19'b1101100101001110000;



  assign ctrlOut_vEnd_done = ctrlOut_vEnd_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_5
      if (reset) begin
        check5_done <= 0;
      end
      else begin
        if (ctrlOut_vEnd_done_enb) begin
          check5_done <= ctrlOut_vEnd_done;
        end
      end
    end

  assign ctrlOut_vStart_done_enb = ctrlOut_vStart_done & rdEnb;



  assign ctrlOut_vStart_lastAddr = pixelOut_0_addr >= 19'b1101100101001110000;



  assign ctrlOut_vStart_done = ctrlOut_vStart_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_4
      if (reset) begin
        check4_done <= 0;
      end
      else begin
        if (ctrlOut_vStart_done_enb) begin
          check4_done <= ctrlOut_vStart_done;
        end
      end
    end

  assign ctrlOut_hEnd_done_enb = ctrlOut_hEnd_done & rdEnb;



  assign ctrlOut_hEnd_lastAddr = pixelOut_0_addr >= 19'b1101100101001110000;



  assign ctrlOut_hEnd_done = ctrlOut_hEnd_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_3
      if (reset) begin
        check3_done <= 0;
      end
      else begin
        if (ctrlOut_hEnd_done_enb) begin
          check3_done <= ctrlOut_hEnd_done;
        end
      end
    end

  assign ctrlOut_hStart_done_enb = ctrlOut_hStart_done & rdEnb;



  assign ctrlOut_hStart_lastAddr = pixelOut_0_addr >= 19'b1101100101001110000;



  assign ctrlOut_hStart_done = ctrlOut_hStart_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_2
      if (reset) begin
        check2_done <= 0;
      end
      else begin
        if (ctrlOut_hStart_done_enb) begin
          check2_done <= ctrlOut_hStart_done;
        end
      end
    end

  assign pixelOut_0_done_enb = pixelOut_0_done & rdEnb;



  assign pixelOut_0_active = pixelOut_0_addr != 19'b1101100101001110000;



  assign #1 Frame_To_Pixels_out2_4_bus_addr_delay_1 = Frame_To_Pixels_out1_addr;

  // Data source for ctrlIn_valid
  initial
    begin : ctrlIn_valid_fileread
      fp_ctrlIn_valid = $fopen("ctrlIn_valid.dat", "r");
      status_ctrlIn_valid = $rewind(fp_ctrlIn_valid);
    end

  always @(Frame_To_Pixels_out2_4_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_valid <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_valid = $fscanf(fp_ctrlIn_valid, "%h", rawData_ctrlIn_valid);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_4_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_4_bus
      if (reset) begin
        holdData_ctrlIn_valid <= 1'bx;
      end
      else begin
        holdData_ctrlIn_valid <= rawData_ctrlIn_valid;
      end
    end

  always @(rawData_ctrlIn_valid or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_4_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_valid_offset <= holdData_ctrlIn_valid;
      end
      else begin
        ctrlIn_valid_offset <= rawData_ctrlIn_valid;
      end
    end

  assign #2 ctrlIn_valid = ctrlIn_valid_offset;

  assign #1 Frame_To_Pixels_out2_3_bus_addr_delay_1 = Frame_To_Pixels_out1_addr;

  // Data source for ctrlIn_vEnd
  initial
    begin : ctrlIn_vEnd_fileread
      fp_ctrlIn_vEnd = $fopen("ctrlIn_vEnd.dat", "r");
      status_ctrlIn_vEnd = $rewind(fp_ctrlIn_vEnd);
    end

  always @(Frame_To_Pixels_out2_3_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_vEnd <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_vEnd = $fscanf(fp_ctrlIn_vEnd, "%h", rawData_ctrlIn_vEnd);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_3_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_3_bus
      if (reset) begin
        holdData_ctrlIn_vEnd <= 1'bx;
      end
      else begin
        holdData_ctrlIn_vEnd <= rawData_ctrlIn_vEnd;
      end
    end

  always @(rawData_ctrlIn_vEnd or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_3_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_vEnd_offset <= holdData_ctrlIn_vEnd;
      end
      else begin
        ctrlIn_vEnd_offset <= rawData_ctrlIn_vEnd;
      end
    end

  assign #2 ctrlIn_vEnd = ctrlIn_vEnd_offset;

  assign #1 Frame_To_Pixels_out2_2_bus_addr_delay_1 = Frame_To_Pixels_out1_addr;

  // Data source for ctrlIn_vStart
  initial
    begin : ctrlIn_vStart_fileread
      fp_ctrlIn_vStart = $fopen("ctrlIn_vStart.dat", "r");
      status_ctrlIn_vStart = $rewind(fp_ctrlIn_vStart);
    end

  always @(Frame_To_Pixels_out2_2_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_vStart <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_vStart = $fscanf(fp_ctrlIn_vStart, "%h", rawData_ctrlIn_vStart);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_2_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_2_bus
      if (reset) begin
        holdData_ctrlIn_vStart <= 1'bx;
      end
      else begin
        holdData_ctrlIn_vStart <= rawData_ctrlIn_vStart;
      end
    end

  always @(rawData_ctrlIn_vStart or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_2_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_vStart_offset <= holdData_ctrlIn_vStart;
      end
      else begin
        ctrlIn_vStart_offset <= rawData_ctrlIn_vStart;
      end
    end

  assign #2 ctrlIn_vStart = ctrlIn_vStart_offset;

  assign #1 Frame_To_Pixels_out2_1_bus_addr_delay_1 = Frame_To_Pixels_out1_addr;

  // Data source for ctrlIn_hEnd
  initial
    begin : ctrlIn_hEnd_fileread
      fp_ctrlIn_hEnd = $fopen("ctrlIn_hEnd.dat", "r");
      status_ctrlIn_hEnd = $rewind(fp_ctrlIn_hEnd);
    end

  always @(Frame_To_Pixels_out2_1_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_hEnd <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_hEnd = $fscanf(fp_ctrlIn_hEnd, "%h", rawData_ctrlIn_hEnd);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_1_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_1_bus
      if (reset) begin
        holdData_ctrlIn_hEnd <= 1'bx;
      end
      else begin
        holdData_ctrlIn_hEnd <= rawData_ctrlIn_hEnd;
      end
    end

  always @(rawData_ctrlIn_hEnd or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_1_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_hEnd_offset <= holdData_ctrlIn_hEnd;
      end
      else begin
        ctrlIn_hEnd_offset <= rawData_ctrlIn_hEnd;
      end
    end

  assign #2 ctrlIn_hEnd = ctrlIn_hEnd_offset;

  assign #1 Frame_To_Pixels_out2_bus_addr_delay_1 = Frame_To_Pixels_out1_addr;

  // Data source for ctrlIn_hStart
  initial
    begin : ctrlIn_hStart_fileread
      fp_ctrlIn_hStart = $fopen("ctrlIn_hStart.dat", "r");
      status_ctrlIn_hStart = $rewind(fp_ctrlIn_hStart);
    end

  always @(Frame_To_Pixels_out2_bus_addr_delay_1, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_ctrlIn_hStart <= 1'bx;
      end
      else if (rdEnb == 1) begin
        status_ctrlIn_hStart = $fscanf(fp_ctrlIn_hStart, "%h", rawData_ctrlIn_hStart);
      end
    end

  // holdData reg for Frame_To_Pixels_out2_bus
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out2_bus
      if (reset) begin
        holdData_ctrlIn_hStart <= 1'bx;
      end
      else begin
        holdData_ctrlIn_hStart <= rawData_ctrlIn_hStart;
      end
    end

  always @(rawData_ctrlIn_hStart or rdEnb)
    begin : stimuli_Frame_To_Pixels_out2_bus_1
      if (rdEnb == 1'b0) begin
        ctrlIn_hStart_offset <= holdData_ctrlIn_hStart;
      end
      else begin
        ctrlIn_hStart_offset <= rawData_ctrlIn_hStart;
      end
    end

  assign #2 ctrlIn_hStart = ctrlIn_hStart_offset;

  // Data source for pixelIn_2
  initial
    begin : pixelIn_2_fileread
      fp_pixelIn_2 = $fopen("pixelIn_2.dat", "r");
      status_pixelIn_2 = $rewind(fp_pixelIn_2);
    end

  always @(Frame_To_Pixels_out1_addr_delay, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_pixelIn_2 <= 8'bx;
      end
      else if (rdEnb == 1) begin
        status_pixelIn_2 = $fscanf(fp_pixelIn_2, "%h", rawData_pixelIn_2);
      end
    end

  // holdData reg for Frame_To_Pixels_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out1
      if (reset) begin
        holdData_pixelIn_2 <= 8'bx;
      end
      else begin
        holdData_pixelIn_2 <= rawData_pixelIn_2;
      end
    end

  always @(rawData_pixelIn_2 or rdEnb)
    begin : stimuli_Frame_To_Pixels_out1_1
      if (rdEnb == 1'b0) begin
        pixelIn_2_offset <= holdData_pixelIn_2;
      end
      else begin
        pixelIn_2_offset <= rawData_pixelIn_2;
      end
    end

  assign #2 pixelIn_2 = pixelIn_2_offset;

  // Data source for pixelIn_1
  initial
    begin : pixelIn_1_fileread
      fp_pixelIn_1 = $fopen("pixelIn_1.dat", "r");
      status_pixelIn_1 = $rewind(fp_pixelIn_1);
    end

  always @(Frame_To_Pixels_out1_addr_delay, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_pixelIn_1 <= 8'bx;
      end
      else if (rdEnb == 1) begin
        status_pixelIn_1 = $fscanf(fp_pixelIn_1, "%h", rawData_pixelIn_1);
      end
    end

  // holdData reg for Frame_To_Pixels_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out1_2
      if (reset) begin
        holdData_pixelIn_1 <= 8'bx;
      end
      else begin
        holdData_pixelIn_1 <= rawData_pixelIn_1;
      end
    end

  always @(rawData_pixelIn_1 or rdEnb)
    begin : stimuli_Frame_To_Pixels_out1_3
      if (rdEnb == 1'b0) begin
        pixelIn_1_offset <= holdData_pixelIn_1;
      end
      else begin
        pixelIn_1_offset <= rawData_pixelIn_1;
      end
    end

  assign #2 pixelIn_1 = pixelIn_1_offset;

  assign Frame_To_Pixels_out1_active = Frame_To_Pixels_out1_addr != 19'b1101100101001110000;



  assign Frame_To_Pixels_out1_enb = Frame_To_Pixels_out1_active & (rdEnb & tb_enb_delay);



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 445040
  always @(posedge clk or posedge reset)
    begin : FrameToPixels_process
      if (reset == 1'b1) begin
        Frame_To_Pixels_out1_addr <= 19'b0000000000000000000;
      end
      else begin
        if (Frame_To_Pixels_out1_enb) begin
          if (Frame_To_Pixels_out1_addr >= 19'b1101100101001110000) begin
            Frame_To_Pixels_out1_addr <= 19'b0000000000000000000;
          end
          else begin
            Frame_To_Pixels_out1_addr <= Frame_To_Pixels_out1_addr + 19'b0000000000000000001;
          end
        end
      end
    end



  assign #1 Frame_To_Pixels_out1_addr_delay = Frame_To_Pixels_out1_addr;

  // Data source for pixelIn_0
  initial
    begin : pixelIn_0_fileread
      fp_pixelIn_0 = $fopen("pixelIn_0.dat", "r");
      status_pixelIn_0 = $rewind(fp_pixelIn_0);
    end

  always @(Frame_To_Pixels_out1_addr_delay, rdEnb, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        rawData_pixelIn_0 <= 8'bx;
      end
      else if (rdEnb == 1) begin
        status_pixelIn_0 = $fscanf(fp_pixelIn_0, "%h", rawData_pixelIn_0);
      end
    end

  // holdData reg for Frame_To_Pixels_out1
  always @(posedge clk or posedge reset)
    begin : stimuli_Frame_To_Pixels_out1_4
      if (reset) begin
        holdData_pixelIn_0 <= 8'bx;
      end
      else begin
        holdData_pixelIn_0 <= rawData_pixelIn_0;
      end
    end

  always @(rawData_pixelIn_0 or rdEnb)
    begin : stimuli_Frame_To_Pixels_out1_5
      if (rdEnb == 1'b0) begin
        pixelIn_0_offset <= holdData_pixelIn_0;
      end
      else begin
        pixelIn_0_offset <= rawData_pixelIn_0;
      end
    end

  assign #2 pixelIn_0 = pixelIn_0_offset;

  assign snkDonen =  ~ snkDone;



  assign resetn =  ~ reset;



  assign tb_enb = resetn & snkDonen;



  // Delay inside enable generation: register depth 1
  always @(posedge clk or posedge reset)
    begin : u_enable_delay
      if (reset) begin
        tb_enb_delay <= 0;
      end
      else begin
        tb_enb_delay <= tb_enb;
      end
    end

  assign rdEnb = (snkDone == 1'b0 ? tb_enb_delay :
              1'b0);



  assign #2 clk_enable = rdEnb;

  initial
    begin : reset_gen
      reset <= 1'b1;
      # (20);
      @ (posedge clk)
      # (2);
      reset <= 1'b0;
    end

  always 
    begin : clk_gen
      clk <= 1'b1;
      # (5);
      clk <= 1'b0;
      # (5);
      if (snkDone == 1'b1) begin
        clk <= 1'b1;
        # (5);
        clk <= 1'b0;
        # (5);
        $stop;
      end
    end

  LLEHDL u_LLEHDL (.clk(clk),
                   .reset(reset),
                   .clk_enable(clk_enable),
                   .pixelIn_0(pixelIn_0),  // uint8
                   .pixelIn_1(pixelIn_1),  // uint8
                   .pixelIn_2(pixelIn_2),  // uint8
                   .ctrlIn_hStart(ctrlIn_hStart),
                   .ctrlIn_hEnd(ctrlIn_hEnd),
                   .ctrlIn_vStart(ctrlIn_vStart),
                   .ctrlIn_vEnd(ctrlIn_vEnd),
                   .ctrlIn_valid(ctrlIn_valid),
                   .ce_out(ce_out),
                   .pixelOut_0(pixelOut_0),  // uint8
                   .pixelOut_1(pixelOut_1),  // uint8
                   .pixelOut_2(pixelOut_2),  // uint8
                   .ctrlOut_hStart(ctrlOut_hStart),
                   .ctrlOut_hEnd(ctrlOut_hEnd),
                   .ctrlOut_vStart(ctrlOut_vStart),
                   .ctrlOut_vEnd(ctrlOut_vEnd),
                   .ctrlOut_valid(ctrlOut_valid)
                   );

  assign pixelOut_0_enb = ce_out & pixelOut_0_active;



  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 445040
  always @(posedge clk or posedge reset)
    begin : c_2_process
      if (reset == 1'b1) begin
        pixelOut_0_addr <= 19'b0000000000000000000;
      end
      else begin
        if (pixelOut_0_enb) begin
          if (pixelOut_0_addr >= 19'b1101100101001110000) begin
            pixelOut_0_addr <= 19'b0000000000000000000;
          end
          else begin
            pixelOut_0_addr <= pixelOut_0_addr + 19'b0000000000000000001;
          end
        end
      end
    end



  assign pixelOut_0_lastAddr = pixelOut_0_addr >= 19'b1101100101001110000;



  assign pixelOut_0_done = pixelOut_0_lastAddr & resetn;



  // Delay to allow last sim cycle to complete
  always @(posedge clk or posedge reset)
    begin : checkDone_1
      if (reset) begin
        check1_done <= 0;
      end
      else begin
        if (pixelOut_0_done_enb) begin
          check1_done <= pixelOut_0_done;
        end
      end
    end

  assign snkDone = check6_done & (check5_done & (check4_done & (check3_done & (check1_done & check2_done))));



  assign #1 pixelOut_0_addr_delay_1 = pixelOut_0_addr;

  // Data source for pixelOut_0_0_expected
  initial
    begin : pixelOut_0_0_expected_fileread
      fp_pixelOut_0_0_expected = $fopen("pixelOut_0_0_expected.dat", "r");
      status_pixelOut_0_0_expected = $rewind(fp_pixelOut_0_0_expected);
    end

  always @(pixelOut_0_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        pixelOut_0_0_expected <= 8'bx;
      end
      else if (ce_out == 1) begin
        status_pixelOut_0_0_expected = $fscanf(fp_pixelOut_0_0_expected, "%h", pixelOut_0_0_expected);
      end
    end

  assign pixelOut_0_ref = pixelOut_0_0_expected;

  always @(posedge clk or posedge reset)
    begin : pixelOut_0_checker
      if (reset == 1'b1) begin
        pixelOut_0_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && pixelOut_0 !== pixelOut_0_ref) begin
          pixelOut_0_testFailure <= 1'b1;
          $display("ERROR in pixelOut_0 at time %t : Expected '%h' Actual '%h'", $time, pixelOut_0_ref, pixelOut_0);
        end
      end
    end

  // Data source for pixelOut_0_1_expected
  initial
    begin : pixelOut_0_1_expected_fileread
      fp_pixelOut_0_1_expected = $fopen("pixelOut_0_1_expected.dat", "r");
      status_pixelOut_0_1_expected = $rewind(fp_pixelOut_0_1_expected);
    end

  always @(pixelOut_0_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        pixelOut_0_1_expected <= 8'bx;
      end
      else if (ce_out == 1) begin
        status_pixelOut_0_1_expected = $fscanf(fp_pixelOut_0_1_expected, "%h", pixelOut_0_1_expected);
      end
    end

  assign pixelOut_1_ref = pixelOut_0_1_expected;

  always @(posedge clk or posedge reset)
    begin : pixelOut_1_checker
      if (reset == 1'b1) begin
        pixelOut_1_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && pixelOut_1 !== pixelOut_1_ref) begin
          pixelOut_1_testFailure <= 1'b1;
          $display("ERROR in pixelOut_1 at time %t : Expected '%h' Actual '%h'", $time, pixelOut_1_ref, pixelOut_1);
        end
      end
    end

  // Data source for pixelOut_0_2_expected
  initial
    begin : pixelOut_0_2_expected_fileread
      fp_pixelOut_0_2_expected = $fopen("pixelOut_0_2_expected.dat", "r");
      status_pixelOut_0_2_expected = $rewind(fp_pixelOut_0_2_expected);
    end

  always @(pixelOut_0_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        pixelOut_0_2_expected <= 8'bx;
      end
      else if (ce_out == 1) begin
        status_pixelOut_0_2_expected = $fscanf(fp_pixelOut_0_2_expected, "%h", pixelOut_0_2_expected);
      end
    end

  assign pixelOut_2_ref = pixelOut_0_2_expected;

  always @(posedge clk or posedge reset)
    begin : pixelOut_2_checker
      if (reset == 1'b1) begin
        pixelOut_2_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && pixelOut_2 !== pixelOut_2_ref) begin
          pixelOut_2_testFailure <= 1'b1;
          $display("ERROR in pixelOut_2 at time %t : Expected '%h' Actual '%h'", $time, pixelOut_2_ref, pixelOut_2);
        end
      end
    end

  assign #1 ctrlOut_hStart_addr_delay_1 = pixelOut_0_addr;

  // Data source for ctrlOut_hStart_expected
  initial
    begin : ctrlOut_hStart_expected_fileread
      fp_ctrlOut_hStart_expected = $fopen("ctrlOut_hStart_expected.dat", "r");
      status_ctrlOut_hStart_expected = $rewind(fp_ctrlOut_hStart_expected);
    end

  always @(ctrlOut_hStart_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_hStart_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_hStart_expected = $fscanf(fp_ctrlOut_hStart_expected, "%h", ctrlOut_hStart_expected);
      end
    end

  assign ctrlOut_hStart_ref = ctrlOut_hStart_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_hStart_checker
      if (reset == 1'b1) begin
        ctrlOut_hStart_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && ctrlOut_hStart !== ctrlOut_hStart_ref) begin
          ctrlOut_hStart_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_hStart at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_hStart_ref, ctrlOut_hStart);
        end
      end
    end

  assign #1 ctrlOut_hEnd_addr_delay_1 = pixelOut_0_addr;

  // Data source for ctrlOut_hEnd_expected
  initial
    begin : ctrlOut_hEnd_expected_fileread
      fp_ctrlOut_hEnd_expected = $fopen("ctrlOut_hEnd_expected.dat", "r");
      status_ctrlOut_hEnd_expected = $rewind(fp_ctrlOut_hEnd_expected);
    end

  always @(ctrlOut_hEnd_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_hEnd_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_hEnd_expected = $fscanf(fp_ctrlOut_hEnd_expected, "%h", ctrlOut_hEnd_expected);
      end
    end

  assign ctrlOut_hEnd_ref = ctrlOut_hEnd_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_hEnd_checker
      if (reset == 1'b1) begin
        ctrlOut_hEnd_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && ctrlOut_hEnd !== ctrlOut_hEnd_ref) begin
          ctrlOut_hEnd_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_hEnd at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_hEnd_ref, ctrlOut_hEnd);
        end
      end
    end

  assign #1 ctrlOut_vStart_addr_delay_1 = pixelOut_0_addr;

  // Data source for ctrlOut_vStart_expected
  initial
    begin : ctrlOut_vStart_expected_fileread
      fp_ctrlOut_vStart_expected = $fopen("ctrlOut_vStart_expected.dat", "r");
      status_ctrlOut_vStart_expected = $rewind(fp_ctrlOut_vStart_expected);
    end

  always @(ctrlOut_vStart_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_vStart_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_vStart_expected = $fscanf(fp_ctrlOut_vStart_expected, "%h", ctrlOut_vStart_expected);
      end
    end

  assign ctrlOut_vStart_ref = ctrlOut_vStart_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_vStart_checker
      if (reset == 1'b1) begin
        ctrlOut_vStart_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && ctrlOut_vStart !== ctrlOut_vStart_ref) begin
          ctrlOut_vStart_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_vStart at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_vStart_ref, ctrlOut_vStart);
        end
      end
    end

  assign #1 ctrlOut_vEnd_addr_delay_1 = pixelOut_0_addr;

  // Data source for ctrlOut_vEnd_expected
  initial
    begin : ctrlOut_vEnd_expected_fileread
      fp_ctrlOut_vEnd_expected = $fopen("ctrlOut_vEnd_expected.dat", "r");
      status_ctrlOut_vEnd_expected = $rewind(fp_ctrlOut_vEnd_expected);
    end

  always @(ctrlOut_vEnd_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_vEnd_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_vEnd_expected = $fscanf(fp_ctrlOut_vEnd_expected, "%h", ctrlOut_vEnd_expected);
      end
    end

  assign ctrlOut_vEnd_ref = ctrlOut_vEnd_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_vEnd_checker
      if (reset == 1'b1) begin
        ctrlOut_vEnd_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && ctrlOut_vEnd !== ctrlOut_vEnd_ref) begin
          ctrlOut_vEnd_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_vEnd at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_vEnd_ref, ctrlOut_vEnd);
        end
      end
    end

  assign #1 ctrlOut_valid_addr_delay_1 = pixelOut_0_addr;

  // Data source for ctrlOut_valid_expected
  initial
    begin : ctrlOut_valid_expected_fileread
      fp_ctrlOut_valid_expected = $fopen("ctrlOut_valid_expected.dat", "r");
      status_ctrlOut_valid_expected = $rewind(fp_ctrlOut_valid_expected);
    end

  always @(ctrlOut_valid_addr_delay_1, ce_out, tb_enb_delay)
    begin
      if (tb_enb_delay == 0) begin
        ctrlOut_valid_expected <= 1'bx;
      end
      else if (ce_out == 1) begin
        status_ctrlOut_valid_expected = $fscanf(fp_ctrlOut_valid_expected, "%h", ctrlOut_valid_expected);
      end
    end

  assign ctrlOut_valid_ref = ctrlOut_valid_expected;

  always @(posedge clk or posedge reset)
    begin : ctrlOut_valid_checker
      if (reset == 1'b1) begin
        ctrlOut_valid_testFailure <= 1'b0;
      end
      else begin
        if (ce_out == 1'b1 && ctrlOut_valid !== ctrlOut_valid_ref) begin
          ctrlOut_valid_testFailure <= 1'b1;
          $display("ERROR in ctrlOut_valid at time %t : Expected '%h' Actual '%h'", $time, ctrlOut_valid_ref, ctrlOut_valid);
        end
      end
    end

  assign testFailure = ctrlOut_valid_testFailure | (ctrlOut_vEnd_testFailure | (ctrlOut_vStart_testFailure | (ctrlOut_hEnd_testFailure | (ctrlOut_hStart_testFailure | (pixelOut_2_testFailure | (pixelOut_0_testFailure | pixelOut_1_testFailure))))));



  always @(posedge clk)
    begin : completed_msg
      if (snkDone == 1'b1) begin
        if (testFailure == 1'b0) begin
          $display("**************TEST COMPLETED (PASSED)**************");
        end
        else begin
          $display("**************TEST COMPLETED (FAILED)**************");
        end
      end
    end

endmodule  // LLEHDL_tb

